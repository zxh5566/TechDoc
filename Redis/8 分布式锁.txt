
【使用SETNX实现分布式锁】

 SETNX key value

 SETNX 返回1，说明该进程获得锁，SETNX将键的值设置为锁的超时时间（当前时间 + 锁的有效时间）。 

 SETNX 返回0，说明其他进程已经获得了锁。进程可以在一个循环中不断地尝试 SETNX 操作，以获得锁


 //////// 解决死锁 ////////


 >> 如果进程获得锁后，断开了与 Redis 的连接（可能是进程挂掉，或者网络中断），如果没有有效的释放锁的机制，那么其他进程都会处于一直等待的状态，即出现“死锁”。

 >> 上面在使用 SETNX 获得锁时，我们将键的值设置为锁的有效时间，进程获得锁后，其他进程还会不断的检测锁是否已超时，如果超时，那么等待的进程也将有机会获得锁。

 >> 然而，锁超时时，我们不能简单地使用 DEL 命令删除键以释放锁。

 >> 考虑以下情况，进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。进程P2，P3正在不断地检测锁是否已释放或者已超时，执行流程如下：


  P2和P3进程读取键 lock.foo 的值，检测锁是否已超时（通过比较当前时间和键 lock.foo 的值来判断是否超时）

  P2和P3进程发现锁 lock.foo 已超时
  
  P2执行 DEL lock.foo命令

  P2执行 SETNX lock.foo命令，并返回1，即P2获得锁

  P3执行 DEL lock.foo命令将P2刚设置的键 lock.foo 删除，这是由于P3刚已检测到锁超时
 
  P3执行 SETNX lock.foo命令，并返回1，即P3获得锁

  P2和P3同时获得了锁


 >> 从上得知，在检测到锁超时后，进程不能直接简单地执行 DEL 删除键的操作以获得锁。

 >> 为了解决上述算法可能出现的多个进程同时获得锁的问题，我们再来看以下的算法。
 
 >> 我们同样假设进程P1已经首先获得了锁 lock.foo，然后进程P1挂掉了。接下来的情况：


  进程P4执行 SETNX lock.foo 以尝试获取锁

  由于进程P1已获得了锁，所以P4执行 SETNX lock.foo 返回0，即获取锁失败

  P4执行 GET lock.foo 来检测锁是否已超时，如果没超时，则等待一段时间，再次检测

  如果P4检测到锁已超时，即当前的时间大于键 lock.foo 的值，P4会执行以下操作  GETSET key value

  由于 GETSET 操作在设置键的值的同时，还会返回键的旧值，通过比较键 lock.foo 的旧值是否小于当前时间，可以判断进程是否已获得锁

  假如另一个进程P5也检测到锁已超时，并在P4之前执行了 GETSET 操作，那么P4的 GETSET 操作返回的是一个大于当前时间的时间戳，这样P4就不会获得锁而继续等待。注意到，即使P4接下来将键lock.foo 的值设置了比P5设置的更大的值也没影响。


 >> 另外，值得注意的是，在进程释放锁，即执行 DEL lock.foo 操作前，需要先判断锁是否已超时。如果锁已超时，那么锁可能已由其他进程获得，这时直接执行 DEL lock.foo 操作会导致把其他进程已获得的锁释放掉。




【代码实现】


<?php
/**
 * 实现Redis分布锁
 */
 
$key        = 'test';       //要更新信息的缓存KEY
$lockKey    = 'lock:'.$key; //设置锁KEY
$lockExpire = 10;           //设置锁的有效期为10秒
 
//获取缓存信息
$result = $redis->get($key);
//判断缓存中是否有数据
if(empty($result))
{
    $status = TRUE;
    while ($status)
    {
        //设置锁值为当前时间戳 + 有效期
        $lockValue = time() + $lockExpire;
        /**
         * 创建锁
         * 试图以$lockKey为key创建一个缓存,value值为当前时间戳
         * 由于setnx()函数只有在不存在当前key的缓存时才会创建成功
         * 所以，用此函数就可以判断当前执行的操作是否已经有其他进程在执行了
         * @var [type]
         */
        $lock = $redis->setnx($lockKey, $lockValue);
        /**
         * 满足两个条件中的一个即可进行操作
         * 1、上面一步创建锁成功;
         * 2、   1）判断锁的值（时间戳）是否小于当前时间    $redis->get()
         *      2）同时给锁设置新值成功    $redis->getset()
         */
        if(!empty($lock) || ($redis->get($lockKey) < time() && $redis->getSet($lockKey, $lockValue) < time() ))
        {
            //给锁设置生存时间
            $redis->expire($lockKey, $lockExpire);
            //******************************
            //此处执行插入、更新缓存操作...
            //******************************
 
            //以上程序走完删除锁
            //检测锁是否过期，过期锁没必要删除
            if($redis->ttl($lockKey))
                $redis->del($lockKey);
            $status = FALSE;
        }else{
            /**
             * 如果存在有效锁这里做相应处理
             *      等待当前操作完成再执行此次请求
             *      直接返回
             */
            sleep(2);//等待2秒后再尝试执行操作
        }
    }
} 