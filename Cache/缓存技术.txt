【碎片化的数据文件缓存】

 >> 将更新频率极低且读取几率高的数据缓存为文件，获取时不再查询数据库而是直接读和解析文件

 >> 例如：从数据库取出网站焦点图数据生成json文件，然后前端ajax读取该json文件获取焦点图


【纯页面静态化】

 >> 通过curl或者file_get_contents读取动态页面的内容存入一个字符串

 >> 替换字符串中的动态链接替换为自己设置规则的静态链接

 >> 打开静态文件，将替换好的字符串写入


【BigPipe技术】

 >> 将页面划分成一个个小块

 >> 利用ob_flush()与flush()将缓存区的内容提前输出给浏览器

 >> 浏览器在一个请求中不断接收并渲染到页面，逐个小块显示

 >> JS部分，不需要立刻执行的部分，可以最后在eval进来


【浏览器缓存】

 ////////////// 强缓存阶段的Header字段 /////////////

 >> Cache-control(HTTP1.1):max-age   public/private  no-cache\no-store\must-revalidate


 ////////////// 协商存阶段的Header字段 /////////////

 >> Last-Modified：末次更新标志（下行）

 >> If-Modified-Since:资源上次的修改时间（上行）

 >> E-Tag：实体与标记（下行）

 >> If-None-Match:资源内容标识（上行）


 ////////////// 合理使用浏览器缓存 /////////////

 >> 页面链接的请求无须做长时间缓存

 >> 敏感数据像订单不宜缓存

 >> 静态资源，通常会设定一个长缓存时间

 >> 冷热数据分离，减少请求量

 >> 不要随意修改文件，建议使用?version=**调用多版本

 >> 不建议使用ETag，尤其分布式


【PHP的APC和Opcache】

 >> Opcache是一种通过将解析的PHP脚本预编译的字节码存放在共享内存中来避免每次加载和解析PHP脚本的开销

 >> 解析器可以直接从共享内存读取已经缓存的字节码，从而提高PHP执行效率

 >> APC是缓存，优化PHP中间代码的架构，可以缓存Opcodes

 >> PHP5.5以后，Zend Opcache整合到PHP中，并可以代替APC使用，此功能默认关闭。